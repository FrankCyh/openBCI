import os
import time

import pandas as pd

from utils.data_utils import *
from utils.database import *
from utils.mne_utils import *
from brainflow import BoardIds, BoardShim, BrainFlowInputParams
from brainflow.data_filter import (DataFilter, DetrendOperations,
                                   WindowOperations)


def stream(
    period: int = 1,
    stride: int = None,
    stream_sec: int = None,
    port: str = "/dev/cu.usbserial-DP04WG3B",
    skip_first_n_seconds: int = 1,
    montage: list[dict] = ELECTRODE_MONTAGE_DEFAULT,
):
    """ 
    Real-time stream from openBCI cython board.

    Arg:
        (period): time interval of stream of data in seconds
        (stride): starting time difference between two period
        (stream_sec): total time of streaming in seconds
        (port): cython board. Default port is from Headset #12 from UofT teaching lab on MacOS machine
        (skip_first_n_seconds): skip the first n seconds of data collected
        (montage): a list of dicts, each dict contains the name and position of an electrode
    Yield:
        a pandas dataframe that consists of all the data streamed in the last `period` seconds
    """
    if stride:
        assert stride <= period, "Invalid stride time, must be smaller than period"
    else:
        stride = period
    
    broad_id = BoardIds.CYTON_BOARD
    broad_desc = BoardShim.get_board_descr(broad_id)
    broad_sampling_rate = int(broad_desc["sampling_rate"])

    #$ Set the board parameters
    board_params = BrainFlowInputParams()
    board_params.serial_port = port

    #$ Create the board object
    board_obj = BoardShim(
        board_id=broad_id,
        input_params=board_params,
    )

    #$ Prepare the board session and start the stream
    board_obj.prepare_session()
    board_obj.start_stream()

    #$ Calculate the nearest power of two for spectral power estimation
    sampling_rate_in_pow_2 = DataFilter.get_nearest_power_of_two(broad_sampling_rate) # start by calculating the nearest power of two to the sampling rate

    #$ Acquire data
    # Pause the execution of the code to allows time for data to accumulate before processing
    time.sleep(skip_first_n_seconds) # filter out the first 3 seconds of data collected
    data = board_obj.get_board_data() # clear all data before enterting the loop
    all_df = pd.DataFrame()
    stride_weight = 1

    start_stream_time = time.time()

    while (True):
        if stream_sec and time.time() - start_stream_time > stream_sec:
            break
        time.sleep(stride * stride_weight if stride_weight > 0 else 0) # stride_weight is negative when the stride is very small
        data = board_obj.get_board_data() # data is numpy.ndarray
        data_df = clean_eeg_dataframe(
            pd.DataFrame(data=data.T, columns=DEFAULT_TXT_HEADER_WO_TIMESTAMP),
            montage,
        )
        all_df = pd.concat([all_df, data_df], axis=0) # combine vertically
        yield all_df[-int(SAMPLE_RATE * period):]
        stride_weight += (SAMPLE_RATE * stride - data_df.shape[0]) / SAMPLE_RATE # adjust the sleep time dynamically
        #print(f"data_df's length is {data_df.shape[0]}")
        #print(f"stride weight is {stride_weight}")

    # Check the status of the session and stop streaming using the release_session() method.
    if board_obj.is_prepared():
        board_obj.stop_stream()
        board_obj.release_session()


def mock_stream(
    txt_path: str,
    period: int = 1,
    stride: int = None,
    montage: list[dict] = ELECTRODE_MONTAGE_DEFAULT,
    mock_sleep: bool = True,
):
    """
    Mock brainflow data stream.
    Implementation: yield data for in `period` seconds, then move forward `stride` seconds, then yield data for `period` seconds, and so on.

    Arg:
        path: path to the file that contains the recorded streaming data. The file should have suffix `txt` and should be generated by openBCI device directly
        period: time interval of stream of data in seconds. If `period` = 1, then the stream will yield 250 samples each time
        stride: starting time difference between two period. 
            `stride` must be smaller than period, otherwise some data will be skipped
            If not specified, `stride` will be equal to period and the data stream won't overlap
        montage: a list of dicts, each dict contains the name and position of an electrode
        mock_sleep: if True, mock sleep for `stride` seconds
    """
    if stride:
        assert stride <= period, "Invalid stride time, must be smaller than period"
    else:
        stride = period

    data_df = get_eeg_from_txt_as_df(txt_path, montage)

    bottom_line_num = data_df.shape[0]
    curr_line_num = 0
    num_line_read = int(SAMPLE_RATE * period)
    num_line_stride = int(SAMPLE_RATE * stride)

    while (curr_line_num + num_line_read < bottom_line_num):
        yield data_df.iloc[curr_line_num: curr_line_num + num_line_read]
        curr_line_num += num_line_stride
        if mock_sleep:
            time.sleep(stride)